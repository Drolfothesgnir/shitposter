i'm creating customizable inline markup for my toy Forum.
// # Shitposter's Completely User-customizable Markup.
//
// It is expected to be used to define INLINE markup for the post content.
// You can set opening, closing, universal and greedy tags along with the escape symbol dynamically during runtime.
// Tags will have the tag name of your choice and the end AST will be built based on it.
//
// WARNING: It works exclusively with simple 1-byte long ASCII symbols as tags.
//
// # Notes and Policies.
//
//  1. This is My Toy and it was created for fun.
//  2. You can use only 1-byte long ASCII symbols for tags.
//  3. A tag can consist of at most [MaxTagLength] characters.
//  4. Nested tags with the same ID will have no effect. Children of the repeated descendants will become
//     children of the "oldest" original tag and the duplicates will not end up in the final AST.
//  5. A universal Tag is one, which has both the opening and the closing tags the same.
//  6. Escape tag ID will be reserved, likely to some ASCII control character.
//  7. The parser will try to make sense out of the User's gibberish and will not return any errors but only a slice of [Warning].
//
// # Behaviour. This will likely change in the future.
//
// Properties of Tags:
//
//  1. ID. Each Tag has unique byte, which triggers the tag's corresponding Action and starts the process of Tokenization.
//     It also serves as unique ID of the Tag and is used for fast lookup for the Tag's info.
//
//  2. Name. Each Tag has Name string associated with it. It does not need to be unique. It's used during the parsing process
//     for naming the AST's Node.
//
//  3. Greed. If a Tag has Greed level > 0, it becomes "greedy". Each Tag can have 3 Greed levels:
//
//     3.1. 0 Level, default Greed level. During the tokenization process, only Tag's string representation will be considered as a Token
//     with the corresponding ID, all next characters will be tokenized normally. Example: Imagine a Tag with ID '$',
//     name "BOLD", string representation "$$" and Greed 0. In string "$$hello$$", the first token will be with ID '$' and have value "$$".
//
//     3.2. 1 Level. All bytes starting from the opening tag and including the closing tag will be considered as this token's value. If
//     the closing tag is not present during the tokenization, the text token will be returned and it's value will
//     be the opening tag string representation only. All next characters will be tokenized normally.
//
//     3.2.1. Example 1: Imagine a tag with id '(', name "URL", tag string "(" and Greed level 1. Imagine also its closing tag with the same
//     name, ID ')' and the tag string ")". In the string "[**some link**](https://google.com)", the whole part "(https://google.com)" will
//     be considered a token and its internal value will be https://google.com.
//
//     3.2.2. Example 2: Imagine the same setting string as in the first example, but the string is now "[**some link**](https://google.com",
//     that is, now closing tag for the "URL". In this case the "(" part will be a text token, and all next bytes parsed normally.
//
//     3.3 2 Level. Same logic as with Level 1, but in the case of missing closing tag, the rest of the string will still be consumed, and
//     token will be for tag not a text. Example: The same setting as in the Example 2, 3.2.2. - "[**some link**](https://google.com". The
//     substring, starting from "(" and to the end, will be a token and it's internal value will be "https://google.com".
//
//  4. Sequence. You can construct your tags from at most [MaxTagLength] (4 by default). You can create tag like this "$}{|". The Sequence
//     is a slice of bytes with length of the defined tag, and with indexes corresponding to indexes of chars in the tag. For tag "$}{|"
//     Sequence will be []byte{'$', '}', '{', '|'}.
//
//  5. Rule. Each UNIVERSAL SINGLE BYTE TAG can have 3 different Rules available to it:
//
//     5.1 0 Rule - No Rule. Default Rule value. Does nothing.
//
//     5.2 1 - Intra-word Rule. Only available for the single-byte "NON-GREEDY" tags. If char, which normally defines a 1-byte long Tag, has alphanumerics, punctuation
//     symbols, OR THE SAME TAG SYMBOL, on BOTH sides, the it will be considered a plain text and not a Tag trigger.
//
//     5.2.1.	Example 1: '_' defines a Tag with name "UNDERLINE" and has
//     Rule 1 on it. In string "image_from_.png" both '_' will be considered a plain text.
//
//     5.2.2. Example 2: In string "_image_from_net.jpg", only 2 last '_'
//     symbols will be a plain text. The first '_' will trigger the Action for the "UNDERLINE" tag, because it has nothing on the left.
//
//     5.2.3. Example 3:  In string "_hello__", both the first and the last '_' will be considered a tokens, but the one before
//     the last will not, since it has "o" on the left and "_" on the right.
//
//     5.3 2 Rule - Tag-VS-Content Rule. Only available for single-byte GREEDY tags. When you have single char tag, like '`',
//     and your text contains symbol "`", it will be interpreted as a closing tag. This might be a problem. Consider Example 1: '`' defines a greedy universal tag
//     with name "CODE". In the string "here is some code: `const rawStr = `hello world`;`". In this case there will be tokens: type text with value ("here is some code: "),
//     type tag with name "CODE" and value "`const rawStr = `", type text with value "hello world" and type tag with name "CODE" and value "`;`". It's likely
//     not what the User intended. The Tag-VS-Content Rule solves this problem by imposing two conditions: 1) You can repeat symbol in tags how, but the lengths of
//     the opening and closing tags must be the same. 2) Length of tags must differ ftom the length of the symbol sequence in the plain text.
//
//     5.3.1. Example 2: The setting from the example 1, but now we make tag length equal 3, by making each tag "```":
//     "here is some code: ```const rawStr = `hello world`;```". Now the "CODE" tag will capture entire "```const rawStr = `hello world`;```" part.
//
//  6. Opening/Closing tag IDs. Each Tag has OpenID and ClosID fields. You have to set at least one of them to ensure the Parser will process them correctly. To make
//     a Tag an opening tag, you have to set its ClosID value to something other than '\000', to inform the Parser that this tag has to be closed with some other Tag.
//     The same with the closing tags: just set the OpenID value to something. To make a Tag universal you have to set both values to the Tag's ID. You can also
//     create one-to-many relationships between tags, by setting Open/ClosID to some conventional or reserved byte, like a control character from ASCII.
//
//     6.1. Example 1 - The Tag expected to be closed with specific other Tag: Imagine you've defined the non-greedy single-byte Tag with name "LINK_TEXT_START",
//     ID '[' and ClosID ']'. Then you've defined the non-greedy Tag with name "LINK_TEXT_END", ID ']' and OpenID '['. During the parsing of the tokens, the Parser,
//     when first encounters the "LINK_TEXT_START", saves its ID to the stack. While the '[' is at the top of the stack and the Parser encounters a closing Tag
//     it checks if the encountered Tag ID is equal to the "LINK_TEXT_START's" ClosID. What will happen next is a good question.
//
//     6.2 Example 2 - one-to-many Tag relationships: Imagine you want to have link URLs and image URLs in your mark up. You create a single-byte Tag with
//     ID '[', name "LINK_URL_START" and ClosID ']'. Then you create a double-byte Tag with sequence "![", ID '!', name "IMAGE_URL_START" and ClosID again ']'.
//     Then you create a single-byte Tag with ID ']', name "LINK_TEXT_END" and OpenID of some reserved or non-printable ASCII character, whatever except '\000'.
//     Now "LINK_TEXT_END" is compatible with both Tags defined before and can close any of them.
//
//  7. GreedyChild. You can set your Tag's field GreedyChild to the ID of some greedy Tag. When the Parser encounters the properly closed Tag with set
//     GreedyChild field, if the next Tag is a greedy tag with ID equal to the GreedyChild field of the first Tag, the value of latter will be considered
//     the property of the first tag and will be assigned to the Node of the first Tag.
//
//     7.1 Example: Imagine that you've defined the non-greedy single-byte Tag with ID '[', name "LINK_TEXT_START", ClosID ']', and GreedyChild
//     set to '('. You've also defined the closing single Tag for the first one: ID ']', name "LINK_TEXT_END", OpenID '['. Lastly, you've defined
//     the single-byte greedy Tag with ID '(' and name "LINK_URL_START". You have the input string "[Hello World!](https://hello-world.com)". The Parser
//     will first create the Node for the link text with inner text "Hello World!". Then it will encounter the "(https://hello-world.com)" part, which
//     it will interpret as a greed-consumed value of the "LINK_TEXT_START" and assign it to the created Node.

what do you think?

This is a fun design, and itâ€™s surprisingly â€œreal parserâ€ for a toy system: youâ€™ve basically built a tiny, runtime-configurable delimiter language with (1) a tokenizer that can be configured per-tag, then (2) a stack-based AST builder with some pragmatic recovery rules. Thatâ€™s a solid direction.

Here are the parts that look especially strong, plus the places I think will bite you (and some concrete tweaks).

## Whatâ€™s strong

* **Runtime tag configuration** (sequence up to MaxTagLength, open/close IDs, universal tags) is a nice â€œmarkup as a tableâ€ model. Itâ€™ll be easy to add new constructs without touching parser logic.
* **Greed levels** are a good simplification of â€œspan parsingâ€ vs â€œnormal token parsingâ€. Level 1 vs 2 gives you a clear knob for recovery behavior.
* **Rule 1 (intra-word)** is exactly the kind of â€œmake it usableâ€ thing markup needs. Your examples show youâ€™ve thought about filenames/identifiers.
* **GreedyChild** is a neat way to model â€œattributes after contentâ€ like Markdown links without turning the whole parser into a grammar.

## The big ambiguity: tokenization precedence

Because you allow sequences up to length 4 and also single-byte tags, youâ€™ll want a clearly defined rule like:

* **Longest-match wins** (maximal munch), then
* If ties, either **priority by tag type** (e.g., greedy > non-greedy, or explicit priority field), or **definition order**.

Otherwise, users will configure stuff like `![` and `[` and get inconsistent behavior depending on scan order.

A very practical approach:

* Precompute a trie of sequences.
* At each position, consume the **longest sequence** that matches.
* If a longest match exists, emit that tag token; otherwise emit text.

This also interacts with your Rule 1: it only applies to **single-byte non-greedy tags**, which is good, but you still need to define â€œdo we try longer tags first?â€ (Iâ€™d say yes, always.)

## Same-ID nesting suppression: good idea, but specify â€œmergeâ€ precisely

Policy 4 (â€œnested tags with the same ID will have no effectâ€¦ children reattach to oldestâ€) is pragmatic, but it needs a crisp operational definition because it can create surprising tree shapes.

Iâ€™d suggest spelling it as:

* When opening tag `X` encountered and `X` is already open on the stack:

  * Do **not** push a new node.
  * Option A: treat the new opening delimiter as **plain text** (simplest mental model).
  * Option B: ignore delimiter but continue parsing (your current description).

Option A is often less surprising to users because they can â€œseeâ€ the extra delimiter in output rather than it silently vanishing. If you keep Option B, add warnings whenever you collapse.

## Greedy tags: your â€œclosing not presentâ€ behavior is great, but watch edge cases

Your level-1 fallback (â€œif missing closing tag, return a text token equal to opening representation onlyâ€) is clever, but it can lead to weird output like a lone â€œ(â€ becoming text while the rest continues normally â€” which is what you want for link URLs. ğŸ‘

For level-2 consuming-to-end, thatâ€™s good for â€œcode fence styleâ€ or â€œquote to endâ€.

Two gotchas:

* **Escapes inside greedy spans**: do you allow escaping the closing delimiter inside a greedy span? If yes, your tokenizer needs to understand escape processing *during* greedy scanning.
* **Performance**: scanning for a closing sequence naively can be O(nÂ²) if you restart searches. Probably fine for a forum toy, but itâ€™s easy to make linear with a simple search.

## Rule 2 (Tag-vs-Content) is useful but could be simplified

The idea is: â€œif content contains the delimiter character, it prematurely closesâ€, so you enforce longer delimiters (` ``` `) so single backticks inside donâ€™t close.

Thatâ€™s a real problem, but your stated constraints:

1. open/close tag lengths must match
2. length must differ from plain-text symbol sequence

(2) is hard to guarantee: users can type â€œ```â€ in plain text too.

A simpler, more predictable rule:

* For greedy universal tags, require **delimiter length >= 2** (or configurable minimum), *or* allow length 1 but then require escaping interior delimiter.
* And define that **the closing delimiter is the first exact match** of the delimiter sequence that is not escaped.

Thatâ€™s basically â€œstandard fenced scanningâ€.

## Warnings: define categories (itâ€™ll make debugging configs way nicer)

You said you return `[]Warning` only. Good. Consider a few standard warning types:

* `UnknownTagByte` (hit a byte that looks like it could be a tag start but no sequence matched)
* `UnclosedTag` (stack not empty at end)
* `UnexpectedClose` (closing tag encountered that doesnâ€™t match stack top; include what you did: ignore / treat as text / pop-until-match)
* `DuplicateSameIDSuppressed`
* `GreedyMissingCloseFallback` (level 1)
* `GreedyMissingCloseConsumeToEnd` (level 2)

If you ever build a â€œpreview why my markup brokeâ€ UI, this list becomes gold.

## Escape semantics: pick one clear rule and apply it everywhere

You mention an escape symbol reserved. The moment you add it, people will expect:

* Escape cancels tag recognition for **the next byte** (classic), *or*
* Escape cancels tag recognition for **the next tag sequence** (nicer for multi-byte tags)

Given you allow multi-byte tags up to length 4, Iâ€™d recommend:

* Escape cancels recognition of the **next tag sequence match** (longest-match) rather than a single byte.
* And inside greedy scanning, escape cancels recognition of a would-be closing delimiter.

## AST building: what do you do on mismatched closes?

You hint at it: â€œWhat will happen next is a good question.â€

This is *the* policy that will define how â€œforgivingâ€ it feels. Common strategies:

1. **Strict stack-top only**: if close doesnâ€™t match top, treat close as text.
2. **Pop-until-match**: if close matches something deeper in stack, auto-close intervening tags (with warnings).
3. **Close-any**: if close is â€œcompatibleâ€ (your one-to-many idea), close top anyway.

For forum input, Iâ€™d go with:

* If close matches stack topâ€™s expected close â†’ close it.
* Else if close matches something deeper â†’ pop until that one (warn for each forced close).
* Else treat as text (warn `UnexpectedClose`).

That gives you â€œtries to make senseâ€ without turning everything into spaghetti.

## One small thing: clarify â€œIDâ€ vs â€œSequenceâ€

You use â€œID is the byte that triggers the tagâ€™s actionâ€, and also â€œsequence is bytes of the defined tagâ€. For multi-byte tags, the â€œIDâ€ is the first byte (like `'!'` for `"!["`). Thatâ€™s fine, but youâ€™ll want to explicitly say:

* **Only the first byte is the ID**, used for quick lookup,
* But **actual recognition is by full sequence**.

Otherwise users might assume any `'!'` triggers `"!["`.

---

### My overall take

This is a very workable design for a configurable inline markup parser, especially with the â€œno errors, only warningsâ€ stance. The two most important things to lock down in writing are:

1. **tokenization precedence** (longest-match, tie-breaking), and
2. **mismatched closing behavior** (stack policy).

If you define those precisely, the rest of your system becomes predictable and a lot easier to extend.

If you want, paste your current â€œwhat happens on mismatched closeâ€ logic (even pseudocode) and I can sanity-check it against your policies/examples and suggest a clean policy that wonâ€™t produce weird ASTs.


addressing your concerns. 
1. "The big ambiguity: tokenization precedence": The answer: all tags must differ their first byte.
     I will not allow two different tags with same first byte. example "![" and "!{" cannot exist at the same time. Sorry, i'm too stupid for the Tries and stuff. I have "Introduction To Algorithms 4th Edition" lying unfinished.
2. "Same-ID nesting suppression": The answer: I'll think about it when i'll finish with the Tokenizer.
3. "Escapes inside greedy spans". The answer: No escapes inside greedy spans. My tags will be completely driven by the Avarice, so no time for escape checks. seriously, i just don't want to mess with it.
4. "Rule 2 (Tag-vs-Content) is useful but could be simplified": The answer: My solution does not use any escapes, so i think it's simpler, also it's linear time so it should be fast.
5. "Warnings: define categories (itâ€™ll make debugging configs way nicer)" The answer: It will be done.
6. "Escape semantics: pick one clear rule and apply it everywhere": The answer: Sorry about forgetting to define escaping rules. i was going to write it but i've spent so much time writing this stuff... The escape symbol will only escape the next character, not the whole tag. In fact my design allows to create the greedy Tag which will wrap whatever you want and put it to the Node. You can use this behaviour to not evaluate the wrapped content anyhow, that is, make it fully escaped

Cool â€” with those constraints, your design becomes a lot simpler and more deterministic. Hereâ€™s how your answers land, plus a few sharp edges to watch for.

## 1) â€œAll tags must differ by first byteâ€

That completely resolves the precedence problem without tries, and itâ€™s a legit tradeoff for a toy forum.

What you *gain*: O(1) dispatch â€” if `b` is the current byte, either itâ€™s a tag-ID or it isnâ€™t.

What you *lose*: you canâ€™t have families like `*` vs `**` vs `***` (or `![` vs `!{`) unless you encode them as different first bytes. Thatâ€™s fine if your tag alphabet is â€œbig enoughâ€ for your use-case.

One small suggestion: document this as a hard invariant because it affects user expectations more than almost anything else:

* â€œNo two tags may share the same first byte. Therefore tag `Sequence[0]` is globally unique.â€

## 3) No escapes inside greedy spans

Also a reasonable simplification.

Just make sure you explicitly accept the consequence: **there is no way to include a closing delimiter inside the span** other than â€œchoose a longer delimiter / different delimiterâ€.

Thatâ€™s consistent with your Rule 2 concept (and how fenced code blocks avoid backtick collisions by using longer fences).

## 4) Rule 2 without escapes, still linear

Yep: if your greedy scan is â€œfind next closing sequenceâ€ and you donâ€™t do escape checks, itâ€™s naturally linear (per token) as long as you search forward once and donâ€™t restart in pathological ways.

Only corner to be careful about: if you implement â€œclosing sequence must be same length as openingâ€ (as you said), enforce it strictly, otherwise you can accidentally allow ambiguous closes.

## 6) Escape escapes only the next *character*

This is fine, but with your â€œunique first byteâ€ rule, it has an important implication:

* Escaping the **first byte** of a tag is enough to prevent the tag from ever triggering (because recognition starts at the first byte).
* Escaping later bytes of a multi-byte sequence doesnâ€™t matter, because those bytes wouldnâ€™t be considered as tag starts anyway.

So your simple â€œescape next characterâ€ semantics line up perfectly with your simplified tokenizer. Nice.

### One gotcha

If your escape byte is reserved and you escape a byte that is itself a tag-ID, you probably want:

* output that escaped byte as literal text, and
* **not** allow it to participate in tag matching later (it wonâ€™t, since itâ€™s already emitted).

Also decide what happens if escape appears at end of input:

* usually: treat escape as literal text and warn.

## â€œUse greedy tag to wrap raw contentâ€ as an escape mechanism

This is a good pattern: effectively a â€œverbatimâ€ or â€œrawâ€ span tag (greedy level 1/2) that produces a node whose content is not re-tokenized / not parsed.

Two things to specify clearly so it stays predictable:

* **Tokenizer vs parser responsibility**:
  If you want â€œrawâ€ to truly block markup evaluation, that should be a *parser* rule: children inside that node are a single text node, not further parsed.
* **Does raw still allow nested raw?**
  If someone writes raw inside raw, do you treat the inner delimiters as just bytes? (Probably yes.)

## The remaining place you should nail down (still)

Even with your simplifications, the AST builder needs one explicit policy:

### What do you do with a closing tag that doesnâ€™t match the top of the stack?

Pick one and document it:

* **Treat as text** (simplest, very stable)
* **Pop-until-match** (more â€œfixesâ€ user input, but can be surprising)
* **Ignore it** (often confusing because user â€œseesâ€ a delimiter but it vanishes)

Given your â€œmake sense of gibberishâ€ stance, â€œpop-until-match with warningsâ€ is usually the most forgiving â€” but â€œtreat as textâ€ is the least surprising.

## A small wording tweak to avoid future confusion

Right now â€œIDâ€ is both â€œfirst byte triggerâ€ and â€œunique IDâ€. With your new restriction, thatâ€™s true, but Iâ€™d explicitly say:

* **ID == first byte of the tagâ€™s sequence**
* Tag recognition happens only when the current byte equals some tagâ€™s ID.

That makes it obvious why `!{` canâ€™t coexist with `![`.

---

If you paste the tokenizer loop (even rough pseudocode), I can sanity-check it against:

* your â€œescape-next-byteâ€ rule,
* greedy level 1 vs 2 fallback,
* and the â€œunique first byteâ€ invariant,

and point out any off-by-one / â€œaccidentally quadraticâ€ traps.

"The remaining place you should nail down (still)": The answer: if the closing tag does not match - treat it as plain text and add a Warning. what do you think?